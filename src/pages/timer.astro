---
import Layout from "@layouts/Layout.astro";
---

<Layout>
  <main id="main-content" class="h-screen w-full">
    <section id="timer" class="h-screen w-full">
      <div id="controls">
        <div id="theme-switch-container" style="display: inline-block;">
          <button id="theme-switch" class="rounded border px-4 py-2">üåù</button>
        </div>
        <div id="variant-controls">
          <div id="segmented-control" role="group" aria-label="Timer variant">
            <button id="variant-fixed" class="segment active" aria-pressed="true">‚è±Ô∏è Fixed</button>
            <button id="variant-target" class="segment" aria-pressed="false">üéØ Target</button>
          </div>
        </div>
        <div id="inline-settings">
          <div id="fixed-settings">
            <select id="time-select">
              <option value="300">5 min</option>
              <option value="600">10 min</option>
              <option value="900">15 min</option>
              <option value="1200">20 min</option>
              <option value="custom">Custom</option>
            </select>
            <div id="custom-time-popover" role="dialog" aria-label="Custom time" hidden>
              <label for="custom-minutes">Minutes:</label>
              <input type="number" id="custom-minutes" placeholder="Minutes" min="1" max="999" />
              <button id="custom-time-ok">OK</button>
            </div>
          </div>
          <div id="target-settings" hidden>
            <input type="time" id="target-time" />
          </div>
          <select id="type-select">
            <option value="break">‚òïÔ∏è Break</option>
            <option value="lab">üßë‚Äçüî¨ Lab</option>
            <option value="session">üéì Session</option>
          </select>
          <input type="text" id="timer-title-input" placeholder="Title" value="Break" />
        </div>
      </div>
      <div id="action-buttons">
        <button id="start-pause-button">‚ñ∂Ô∏è Start</button>
        <button id="reset-button">üîÑ Reset</button>
      </div>
      <div
        id="countdown"
        class="flex h-screen w-full items-start justify-center"
        style="margin-top: 40%;"
      >
      </div>
    </section>
  </main>
</Layout>

<script>
  const countdownElement = document.getElementById("countdown")!;
  const timeSelect = document.getElementById("time-select")! as HTMLSelectElement;
  const customMinutesInput = document.getElementById("custom-minutes")! as HTMLInputElement;
  const customTimePopover = document.getElementById("custom-time-popover")!;
  const customTimeOkButton = document.getElementById("custom-time-ok")!;
  const startPauseButton = document.getElementById("start-pause-button")!;
  const resetButton = document.getElementById("reset-button")!;
  const themeSwitch = document.getElementById("theme-switch")!;
  const targetTimeInput = document.getElementById("target-time")! as HTMLInputElement;
  const variantFixed = document.getElementById("variant-fixed")!;
  const variantTarget = document.getElementById("variant-target")!;
  const fixedSettings = document.getElementById("fixed-settings")!;
  const targetSettings = document.getElementById("target-settings")!;
  const timerTitleInput = document.getElementById("timer-title-input")! as HTMLInputElement;
  const typeSelect = document.getElementById("type-select")! as HTMLSelectElement;

  const titleDefaults: Record<string, string> = {
    break: "Break",
    lab: "Lab",
    session: "Session"
  };
  let previousType = "break";

  const countdownDefaultText = "‚è±Ô∏è time for...";
  const sessionStartingText = "Session starting soon...";
  const targetTimeErrorText = "‚ö†Ô∏è Target time must be in the future";

  let timerInterval: string | number | NodeJS.Timeout | undefined;
  let currentVariant: "fixed" | "target" = "fixed";
  let timerState: "idle" | "running" | "paused" = "idle";
  let remainingTime: number = 0;

  let initialTimeLeft: number = 0;

  function updateTimer(timeLeft: number) {
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    const selectedType = (document.getElementById("type-select") as HTMLSelectElement).value;
    const emoji = selectedType === "break" ? "‚òïÔ∏è" : selectedType === "lab" ? "üßë‚Äçüî¨" : "üéì";
    const title = timerTitleInput.value || titleDefaults[selectedType] || "Timer";
    const totalTime = initialTimeLeft > 0 ? initialTimeLeft : parseInt(timeSelect.value, 10);
    const progressPercentage = (timeLeft / totalTime) * 100;

    const segments = Array.from({ length: totalTime / 15 }, (_, i) => {
      const segmentPosition = (i / (totalTime / 15)) * 100;
      return `<div style="position: absolute; left: ${segmentPosition}%; width: 1px; height: 100%; background-color: #ffffff; z-index: 1;"></div>`;
    }).join("");

    countdownElement.innerHTML = `
      <div id="countdown-emoji">${emoji}</div>
      <div id="countdown-title">${title}</div>
      <div id="countdown-time">${minutes}:${seconds.toString().padStart(2, "0")}</div>
      <div id="progress-bar-container" style="position: relative; width: 100%; height: 10px; background-color: #e0e0e0; margin-top: 10px;">
        ${segments}
        <div id="progress-bar" style="position: absolute; right: ${100 - progressPercentage}%; width: ${progressPercentage}%; height: 100%; background-color: #282728; z-index: 0;"></div>
      </div>
    `;
  }

  function handleStartPause() {
    if (timerState === "idle") {
      startTimer();
    } else if (timerState === "running") {
      pauseTimer();
    } else if (timerState === "paused") {
      resumeTimer();
    }
  }

  function startTimer() {
    let timeLeft: number;

    // Check which variant is selected
    if (currentVariant === "target") {
      if (!targetTimeInput.value) {
        countdownElement.textContent = "‚ö†Ô∏è Please set a target time";
        setTimeout(() => {
          countdownElement.textContent = countdownDefaultText;
        }, 2000);
        return;
      }

      const now = new Date();
      const [hours, minutes] = targetTimeInput.value.split(":").map(Number);
      const targetDate = new Date();
      targetDate.setHours(hours, minutes, 0, 0);

      // Validate target time is in the future
      if (targetDate <= now) {
        countdownElement.textContent = targetTimeErrorText;
        setTimeout(() => {
          countdownElement.textContent = countdownDefaultText;
        }, 2000);
        return;
      }

      timeLeft = Math.floor((targetDate.getTime() - now.getTime()) / 1000);
    } else {
      // Check if "custom" is selected but no custom time has been set yet
      if (timeSelect.value === "custom") {
        countdownElement.textContent = "‚ö†Ô∏è Please set a custom time";
        setTimeout(() => {
          countdownElement.textContent = countdownDefaultText;
        }, 2000);
        return;
      }
      timeLeft = parseInt(timeSelect.value, 10);
    }

    initialTimeLeft = timeLeft;
    remainingTime = timeLeft;
    runTimer();
  }

  function runTimer() {
    timerState = "running";
    startPauseButton.textContent = "‚è∏Ô∏è Pause";
    updateTimer(remainingTime);

    timerInterval = setInterval(() => {
      if (remainingTime > 0) {
        remainingTime -= 1;
        updateTimer(remainingTime);
      } else {
        clearInterval(timerInterval);
        timerState = "idle";
        countdownElement.textContent = sessionStartingText;
        startPauseButton.textContent = "‚ñ∂Ô∏è Start";
      }
    }, 1000);
  }

  function pauseTimer() {
    clearInterval(timerInterval);
    timerState = "paused";
    startPauseButton.textContent = "‚ñ∂Ô∏è Resume";
  }

  function resumeTimer() {
    runTimer();
  }

  function resetTimer() {
    clearInterval(timerInterval);
    targetTimeInput.value = "";
    resetCustomOption();
    timeSelect.value = "300";
    customMinutesInput.value = "";
    closeCustomTimePopover();
    currentVariant = "fixed";
    updateVariantUI();
    countdownElement.textContent = countdownDefaultText;
    timerState = "idle";
    startPauseButton.textContent = "‚ñ∂Ô∏è Start";
    initialTimeLeft = 0;
    remainingTime = 0;
    // Reset title to default for current type
    typeSelect.value = "break";
    timerTitleInput.value = titleDefaults["break"];
    previousType = "break";
  }

  function updateVariantUI() {
    if (currentVariant === "fixed") {
      variantFixed.classList.add("active");
      variantFixed.setAttribute("aria-pressed", "true");
      variantTarget.classList.remove("active");
      variantTarget.setAttribute("aria-pressed", "false");
      fixedSettings.hidden = false;
      targetSettings.hidden = true;
    } else {
      variantTarget.classList.add("active");
      variantTarget.setAttribute("aria-pressed", "true");
      variantFixed.classList.remove("active");
      variantFixed.setAttribute("aria-pressed", "false");
      fixedSettings.hidden = true;
      targetSettings.hidden = false;
    }
  }

  function openCustomTimePopover() {
    customTimePopover.hidden = false;
    customMinutesInput.focus();
  }

  function closeCustomTimePopover() {
    customTimePopover.hidden = true;
  }

  function applyCustomTime() {
    const customMinutes = parseInt(customMinutesInput.value, 10);
    if (customMinutes && customMinutes > 0) {
      const customOption = timeSelect.querySelector('option[value="custom"]') as HTMLOptionElement;
      // Update the option's value to the seconds and text to show the minutes
      customOption.value = (customMinutes * 60).toString();
      customOption.textContent = `${customMinutes} min`;
      timeSelect.value = customOption.value;
    }
    closeCustomTimePopover();
  }

  function resetCustomOption() {
    const customOption = timeSelect.querySelector('option[value^="custom"], option:last-child') as HTMLOptionElement;
    if (customOption && customOption.textContent !== 'Custom') {
      customOption.value = 'custom';
      customOption.textContent = 'Custom';
    }
  }

  // Event listeners
  startPauseButton.addEventListener("click", handleStartPause);
  resetButton.addEventListener("click", resetTimer);

  variantFixed.addEventListener("click", () => {
    currentVariant = "fixed";
    closeCustomTimePopover(); // Close popover when switching variants
    updateVariantUI();
  });

  variantTarget.addEventListener("click", () => {
    currentVariant = "target";
    closeCustomTimePopover(); // Close popover when switching variants
    updateVariantUI();
  });

  timeSelect.addEventListener("change", () => {
    closeCustomTimePopover(); // Always close first
    if (timeSelect.value === "custom") {
      openCustomTimePopover();
    } else {
      // Reset custom option when a preset is selected
      resetCustomOption();
      customMinutesInput.value = '';
    }
  });

  customTimeOkButton.addEventListener("click", () => {
    applyCustomTime();
  });

  // Close popover when clicking outside
  document.addEventListener("click", (e) => {
    const target = e.target as Element;

    // Check if click is outside the fixed settings container
    if (!fixedSettings.contains(target) && !customTimePopover.hidden) {
      closeCustomTimePopover();
    }
  });

  // Handle Enter and Escape keys in custom minutes input
  customMinutesInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      applyCustomTime();
    } else if (e.key === "Escape") {
      closeCustomTimePopover();
    }
  });

  // Handle Escape key globally when popover is open
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && !customTimePopover.hidden) {
      closeCustomTimePopover();
    }
  });



  // Update title when type changes (only if title matches previous default)
  typeSelect.addEventListener("change", () => {
    const currentTitle = timerTitleInput.value;
    const previousDefault = titleDefaults[previousType];
    const newType = typeSelect.value;
    
    // Only update if the current title matches the previous type's default
    if (currentTitle === previousDefault) {
      timerTitleInput.value = titleDefaults[newType] || newType;
    }
    previousType = newType;
  });

  // Initial state
  countdownElement.textContent = countdownDefaultText;
  updateVariantUI();
  
  // Set target time to current hour
  const now = new Date();
  const currentHour = now.getHours().toString().padStart(2, '0');
  const currentMinute = now.getMinutes().toString().padStart(2, '0');
  targetTimeInput.value = `${currentHour}:${currentMinute}`;

  themeSwitch.addEventListener("click", () => {
    const currentTheme = document.documentElement.getAttribute("data-theme");
    const newTheme = currentTheme === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", newTheme);
    themeSwitch.textContent = newTheme === "dark" ? "‚òÄÔ∏è" : "üåù";
  });
</script>

<style>
  :root {
    --dropdown-bg-light: #ffffff;
    --dropdown-bg-dark: #333333;
    --dropdown-text-light: #000000;
    --dropdown-text-dark: #ffffff;
    --progress-bar-bg-light: #e0e0e0;
    --progress-bar-bg-dark: #333333;
    --progress-bar-fill-light: #282728;
    --progress-bar-fill-dark: #ffa500;
  }

  [data-theme="light"] {
    --dropdown-bg: var(--dropdown-bg-light);
    --dropdown-text: var(--dropdown-text-light);
    --progress-bar-bg: var(--progress-bar-bg-light);
    --progress-bar-fill: var(--progress-bar-fill-light);
  }

  [data-theme="dark"] {
    --dropdown-bg: var(--dropdown-bg-dark);
    --dropdown-text: var(--dropdown-text-dark);
    --progress-bar-bg: var(--progress-bar-bg-dark);
    --progress-bar-fill: var(--progress-bar-fill-dark);
  }

  #time-controls select,
  #type-controls select {
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
  }

  #progress-bar-container {
    background-color: var(--progress-bar-bg);
  }

  #progress-bar {
    background-color: var(--progress-bar-fill);
  }

  #timer {
    @apply pb-6 pt-4 text-center;
  }
  #timer h1 {
    @apply text-3xl font-bold;
  }
  #controls {
    @apply mt-4 flex items-center justify-center;
    gap: 1rem;
    flex-wrap: wrap;
    padding: 0 1rem;
  }

  /* Responsive: stack vertically on small screens */
  @media (max-width: 640px) {
    #controls {
      flex-direction: column;
      gap: 1rem;
    }
  }

  /* Segmented control styles */
  #variant-controls {
    display: inline-block;
  }
  #segmented-control {
    display: flex;
    @apply rounded border;
    overflow: hidden;
    height: 32px;
  }
  #segmented-control .segment {
    @apply px-6 py-1;
    border: none;
    border-radius: 0;
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
    cursor: pointer;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 140px;
  }

  @media (max-width: 640px) {
    #segmented-control .segment {
      width: 110px;
      @apply px-3;
    }
  }
  #segmented-control .segment:not(:last-child) {
    border-right: 1px solid var(--dropdown-text);
  }
  #segmented-control .segment.active {
    background-color: #FFA500;
    color: #000000;
  }
  #segmented-control .segment:hover:not(.active) {
    background-color: rgba(255, 165, 0, 0.3);
  }

  /* Inline settings */
  #theme-switch {
    height: 32px;
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 60px;
  }
  #inline-settings {
    display: flex;
    gap: 1rem;
    align-items: center;
  }
  #inline-settings select,
  #inline-settings input {
    @apply rounded border px-3 py-1;
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
    height: 32px;
    min-width: 100px;
  }

  @media (max-width: 640px) {
    #inline-settings {
      gap: 0.5rem;
    }
    #inline-settings select,
    #inline-settings input {
      min-width: 80px;
      @apply px-2;
    }
  }
  
  /* Custom time popover */
  #fixed-settings {
    position: relative;
  }
  #custom-time-popover {
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 8px;
    @apply rounded border p-3;
    background-color: rgb(var(--color-fill));
    color: var(--dropdown-text);
    z-index: 100;
    min-width: 160px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    flex-direction: column;
    gap: 8px;
  }
  #custom-time-popover:not([hidden]) {
    display: flex;
  }
  #custom-time-popover label {
    font-size: 0.875rem;
    margin-bottom: 4px;
  }
  #custom-time-popover input {
    width: 100%;
    @apply rounded border px-2 py-1;
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
    height: 32px;
  }
  #custom-time-popover button {
    @apply rounded border px-3 py-1;
    background-color: #FFA500;
    color: #000000;
    height: 28px;
    align-self: flex-end;
    min-width: 50px;
  }


  #controls > button,
  #action-buttons > button {
    @apply rounded border px-6 py-2;
    @apply flex items-center justify-center;
    height: 32px;
    min-width: 140px;
  }

  @media (max-width: 640px) {
    #controls > button,
    #action-buttons > button {
      min-width: 100px;
      @apply px-4;
    }
  }

  /* Group action buttons together on their own row */
  #action-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
    width: 100%;
    margin-top: 1rem;
  }

  @media (max-width: 640px) {
    #action-buttons {
      gap: 0.5rem;
    }
  }

  #countdown {
    @apply mt-4 font-mono text-6xl;
    display: block;
  }
  #countdown-emoji {
    font-size: 4rem;
  }
  #countdown-title {
    font-size: 2rem;
    margin-top: 0.5rem;
    font-family: system-ui, sans-serif;
  }
  #countdown-time {
    font-size: 6rem;
    margin-top: 0.25rem;
  }
  #timer-title-input {
    @apply rounded border px-3 py-1;
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
    height: 32px;
    min-width: 120px;
  }
  button:hover, select:hover, input[type="time"]:hover, input[type="number"]:hover {
    border-width: 3px; /* Make border thicker on hover */
    border-color: #FFA500; /* Orange border color used on the website */
    cursor: pointer;
  }
  #custom-time-popover button:hover {
    background-color: #FF8C00;
  }
  #time-controls select:disabled:hover {
    border-width: 1px;
    border-color: initial;
    cursor: not-allowed;
  }
</style>